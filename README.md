# Processor-Emulator

## Installation 

```
git clone https://github.com/d3clane/Processor-Emulator.git
make -f asmMake
make -f spuMake
```

## Description 

The project consists of two programs:
- Assembler
- SPU (software processor unit) 

Assembler converts human-readable text format into machine code (binary file with ints inside of it). After that this code can be executed by SPU. SPU is built as stack machine.

In this project I have used some kind of auto generation of code because there a lot in common between different programs - assembler and spu (for example - instructions). It is implemented by using [define file](Common/Commands.h) that can create different code based on how is define defined.  

SPU supports registers, stack and RAM.

## Assembler 

Assembler code example is available in [file](Assembler/code.txt). It is auto-generated code of program solving quadratic equations, generated by backend of my [programming language](https://github.com/d3clane/ProgrammingLanguage).

Assembler understand these typed of operations:
- Register based operations - push rax / pop rax
- Stack based operations - add / sub / mul etc
- Jump commands - jmp, je, jg, etc
- RAM based operations - push [5](means push on stack from memory adr 5), pop [5](means pop from stack to memory adr 5).
- Mixed: push [rax + 5], push [rax]
- in / out / outc to work with input / output from stdio. Outc puts char with it's ASCII code.

The fact that operations uses different arguments is saved in operation id in machine code. It is added using bitwise or with [constants](/Common/Common.h). Also, every command in machine code is fixed-length; however, there could be different size because of argument. For example, "push 5" takes more than "add" because I need machine code for argument also.

Assembler supports labels (used for jumps) and procedures (functions).

Assembler uses two-pass compilation in order to precalculate labels addresses, that are lower than their first call and set the address properly.

Also, assembler adds signature info into the file beginning so that any SPU could check it and compare with it's own signature. It is done because machine code designed for my SPU shouldn't be executed on others to avoid bugs.

## Spu

Spu checks signature from machine code and begins executing it. It has registers, ram, two stacks and ip pointer.

Ip pointer is instruction pointer. According to the naming - it is used to understand which instruction to execute next, changed by jumps and after executing each instruction.

Registers are supposed to be a faster storage for data than ram, but, unfortunately, in SPU they are equal in performance. Ram is just a fixed-size array with data in it.

First stack is used for data, all arithmetic and logic operations are made on stack because it is a stack based machine. And another stack is used for functions return addresses as it is in Harvard architecture.

